// encryption.ts
// Client-side envelope encryption for PII/documents.
// Uses AES-GCM for payload encryption and RSA-OAEP for DEK wrapping.
// Swap RSA-OAEP for X25519-based ECDH if preferred.

export type CipherBundle = {
  ciphertext: Uint8Array;
  iv: Uint8Array;
  dekRaw: Uint8Array; // export for wrapping only; never store plaintext
};

export type Envelope = {
  envelopeId: string;
  wrappedDek: Uint8Array;
  alg: "RSA-OAEP" | "X25519-XSalsa20"; // label only
  audience: "org" | "role" | "reviewer";
};

export async function generateAesGcmKey(): Promise<CryptoKey> {
  return crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
}

export async function exportRawKey(key: CryptoKey): Promise<Uint8Array> {
  const raw = await crypto.subtle.exportKey("raw", key);
  return new Uint8Array(raw);
}

export async function encryptAesGcm(payload: Uint8Array, aad?: Uint8Array): Promise<CipherBundle> {
  const key = await generateAesGcmKey();
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const params: AesGcmParams & { additionalData?: BufferSource } = { name: "AES-GCM", iv };
  if (aad) params.additionalData = aad;

  const ciphertext = new Uint8Array(await crypto.subtle.encrypt(params, key, payload));
  const dekRaw = await exportRawKey(key);
  return { ciphertext, iv, dekRaw };
}

export async function importOrgRsaPublicKey(spkiDer: ArrayBuffer): Promise<CryptoKey> {
  return crypto.subtle.importKey(
    "spki",
    spkiDer,
    { name: "RSA-OAEP", hash: "SHA-256" },
    false,
    ["encrypt"]
  );
}

export async function wrapDekRsaOaep(dekRaw: Uint8Array, orgPub: CryptoKey): Promise<Uint8Array> {
  const wrapped = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, orgPub, dekRaw);
  return new Uint8Array(wrapped);
}

export async function sha256(data: Uint8Array): Promise<string> {
  const digest = await crypto.subtle.digest("SHA-256", data);
  return Array.from(new Uint8Array(digest)).map((b) => b.toString(16).padStart(2, "0")).join("");
}

// High-level helper: encrypt payload, create envelopes, and return uploadable bundle
export async function encryptAndEnvelope(
  payload: Uint8Array,
  aad: Uint8Array,
  audiences: { orgSpkiDer: ArrayBuffer; rolePubKeys?: ArrayBuffer[]; reviewerPubKeys?: ArrayBuffer[] }
) {
  const bundle = await encryptAesGcm(payload, aad);
  const orgPub = await importOrgRsaPublicKey(audiences.orgSpkiDer);
  const orgWrapped = await wrapDekRsaOaep(bundle.dekRaw, orgPub);

  const commitmentHash = await sha256(bundle.ciphertext);
  const envelopes: Envelope[] = [
    { envelopeId: `org-${commitmentHash}`, wrappedDek: orgWrapped, alg: "RSA-OAEP", audience: "org" },
    // Optional: add role/reviewer envelopes using your chosen scheme
  ];

  return {
    ciphertext: bundle.ciphertext,
    iv: bundle.iv,
    envelopes,
    commitmentHash,
  };
}